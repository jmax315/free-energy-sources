There's one crucial question for any new program: What to call it? I'm
making an executive decision, and saying that it's called `rexp`.

Next, there are two pressing questions of architecture that
immediately present themselves:

1. How shall we interact with the progam under study?

1. How shall we interact with the user?

As to interacting with the user, I'm going to start with a
command-line program. It's faster and easier to get up and running,
and since the initial output will be a list of files loaded by the
target program, it doesn't seem that a GUI would be much of an
improvement over simply printing the list.

Interacting with the target program is a trickier decision. I _could_
simply modify the program's code, perhaps by packaging `rexp` as a gem
and adding it to the target.

I don't like this idea for a couple reasons: First, I don't want to
modify the target program any more than I must, and second, I want my
code to be loaded as early as possible, before any of the target
program's code is. That gets potentially tricky if `rexp` is just one
more gem in the target's Gemfile.

There's one more consideration that I need to worry about. I didn't
mention it when talking about setting up my guinea pig, `consul`, but
I used [rvm](https://rvm.io/) to ensure that I was using the correct
version of Ruby, and to isolate the gems it uses. I need to respect
`rvm's` control of the runtime environment.

All of these things point towards a different design: After starting
up `rexp`, it opens a bidirectonal pipe and spawns a child
process. The child process starts up a login shell, with commands to
start a Ruby interpreter which will loading up some custom code to get
its hooks into the target, and run the target application.

The login shell ensures that all of `rvm's` magic is respected, and
the pipe enables communication between `rexp` and it's module in the
target process. All of the actual direct manipulation of the target is
done by the module.
